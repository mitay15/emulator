часть 1/3 - dashboard.py
from gui.dashboard import run_dashboard

if __name__ == "__main__":
    run_dashboard()

часть 1/3 - analysis/cob_uam_reconstruct.py
from typing import List, Dict, Any
from parser.timeline import TimelineEvent


def reconstruct_cob_uam(events: List[TimelineEvent]) -> List[Dict[str, Any]]:
    """
    Берём реальные CARBS (из USER ENTRY и Wizard),
    смотрим BG в окне 4 часа, считаем пик и ΔBG на 10g.
    """
    out = []

    meals = [e for e in events if e.kind == "CARBS"]
    bgs = [e for e in events if e.kind == "BG"]

    def bg_series_after(ts_start: int, window_min: int = 240):
        ts_end = ts_start + window_min * 60 * 1000
        return [bg for bg in bgs if ts_start <= bg.ts <= ts_end]

    for meal in meals:
        carbs = meal.data.get("carbs") or 0.0
        ts = meal.ts
        series = bg_series_after(ts)

        if not series or carbs <= 0:
            continue

        bg0 = series[0].data.get("glucose") or series[0].data.get("value")
        bg_max = max(
            (bg.data.get("glucose") or bg.data.get("value") or bg0)
            for bg in series
        )
        delta = bg_max - bg0

        out.append({
            "timestamp": ts,
            "carbs": carbs,
            "bg_start": bg0,
            "bg_peak": bg_max,
            "delta": delta,
            "delta_per_10g": delta / (carbs / 10.0) if carbs > 0 else None,
        })

    return out

часть 1/3 - analysis/plots.py
# analysis/plots.py
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple

import matplotlib.pyplot as plt
from matplotlib.dates import DateFormatter, AutoDateLocator
from matplotlib import dates as mdates
from matplotlib.offsetbox import AnnotationBbox, TextArea

from parser.timeline import TimelineEvent

TIR_LOW = 3.9
TIR_HIGH = 10.0


def _ts_to_dt(ts_ms: int) -> datetime:
    return datetime.fromtimestamp(ts_ms / 1000)


def _setup_time_axis(ax, ylabel: str):
    ax.set_ylabel(ylabel)
    ax.grid(True, which="both", linestyle="--", linewidth=0.4, alpha=0.6)
    ax.xaxis.set_major_formatter(DateFormatter("%d.%m %H:%M"))
    ax.xaxis.set_major_locator(AutoDateLocator())


def _bg_to_mmol(v: Optional[float]) -> Optional[float]:
    if v is None:
        return None
    return v / 18.0 if v > 30 else v


def _interp_bg_at_ts(bg_events: List[TimelineEvent], ts_ms: int) -> Tuple[Optional[datetime], Optional[float]]:
    """
    Interpolate BG (mmol/L) at timestamp ts_ms (ms).
    Returns (datetime, bg_mmol) or (None, None) if impossible.
    """
    if not bg_events:
        return None, None

    bg_sorted = sorted(bg_events, key=lambda e: e.ts)

    if ts_ms <= bg_sorted[0].ts:
        v = _bg_to_mmol(bg_sorted[0].data.get("glucose") or bg_sorted[0].data.get("value"))
        return _ts_to_dt(bg_sorted[0].ts), v
    if ts_ms >= bg_sorted[-1].ts:
        v = _bg_to_mmol(bg_sorted[-1].data.get("glucose") or bg_sorted[-1].data.get("value"))
        return _ts_to_dt(bg_sorted[-1].ts), v

    left = None
    right = None
    for i in range(1, len(bg_sorted)):
        if bg_sorted[i - 1].ts <= ts_ms <= bg_sorted[i].ts:
            left = bg_sorted[i - 1]
            right = bg_sorted[i]
            break

    if left is None or right is None:
        nearest = min(bg_sorted, key=lambda e: abs(e.ts - ts_ms))
        v = _bg_to_mmol(nearest.data.get("glucose") or nearest.data.get("value"))
        return _ts_to_dt(nearest.ts), v

    t0, t1 = left.ts, right.ts
    v0 = _bg_to_mmol(left.data.get("glucose") or left.data.get("value"))
    v1 = _bg_to_mmol(right.data.get("glucose") or right.data.get("value"))

    if v0 is None or v1 is None:
        nearest = left if abs(ts_ms - left.ts) < abs(ts_ms - right.ts) else right
        v = _bg_to_mmol(nearest.data.get("glucose") or nearest.data.get("value"))
        return _ts_to_dt(nearest.ts), v

    if t1 == t0:
        interp_v = v0
    else:
        frac = (ts_ms - t0) / (t1 - t0)
        interp_v = v0 + (v1 - v0) * frac

    return _ts_to_dt(ts_ms), interp_v


def _make_tooltip(ax, initial_text: str = "") -> Tuple[AnnotationBbox, TextArea]:
    ta = TextArea(initial_text)
    ab = AnnotationBbox(
        ta,
        (0, 0),
        xybox=(20, 20),
        xycoords='data',
        boxcoords="offset points",
        pad=0.4,
        bboxprops=dict(facecolor="white", edgecolor="black", alpha=0.95),
        arrowprops=dict(arrowstyle="->")
    )
    ab.set_visible(False)
    ax.add_artist(ab)
    return ab, ta


def _detect_uam_segments(bg_events: List[TimelineEvent], carb_events: List[TimelineEvent]):
    if len(bg_events) < 2:
        return []

    carb_times = [c.ts for c in carb_events]
    segments = []

    def has_recent_carbs(ts, window_ms=2 * 60 * 60 * 1000):
        return any(abs(ts - t) <= window_ms for t in carb_times)

    bg_sorted = sorted(bg_events, key=lambda e: e.ts)

    for i in range(1, len(bg_sorted)):
        prev = bg_sorted[i - 1]
        cur = bg_sorted[i]

        dt_min = (cur.ts - prev.ts) / 60000.0
        if dt_min <= 0:
            continue

        prev_bg = _bg_to_mmol(prev.data.get("glucose") or prev.data.get("value"))
        cur_bg = _bg_to_mmol(cur.data.get("glucose") or cur.data.get("value"))
        if prev_bg is None or cur_bg is None:
            continue

        dv = cur_bg - prev_bg
        rate = dv / dt_min

        if rate > 0.2 and not has_recent_carbs(cur.ts):
            segments.append((prev.ts, cur.ts))

    return segments


def _unique_carbs_total(carbs: List[TimelineEvent]) -> float:
    seen = set()
    total = 0.0
    for e in carbs:
        c = float(e.data.get("carbs", 0.0) or 0.0)
        key = (e.ts, round(c, 1))
        if key in seen:
            continue
        seen.add(key)
        total += c
    return total


def _compute_stats(bg: List[TimelineEvent],
                   carbs: List[TimelineEvent],
                   smb: List[TimelineEvent],
                   bolus: List[TimelineEvent]):
    bg_vals = []
    for e in bg:
        v = e.data.get("glucose") or e.data.get("value")
        if v is not None:
            bg_vals.append(_bg_to_mmol(v))

    bg_vals = [v for v in bg_vals if v is not None]

    avg_bg = sum(bg_vals) / len(bg_vals) if bg_vals else None
    min_bg = min(bg_vals) if bg_vals else None
    max_bg = max(bg_vals) if bg_vals else None

    total_carbs = _unique_carbs_total(carbs)
    total_smb = sum(e.data.get("insulin", 0.0) for e in smb)
    total_bolus = sum(e.data.get("insulin", 0.0) for e in bolus)
    total_insulin = total_smb + total_bolus

    in_range = [v for v in bg_vals if TIR_LOW <= v <= TIR_HIGH]
    tir = (len(in_range) / len(bg_vals) * 100.0) if bg_vals else None

    return {
        "avg_bg": avg_bg,
        "min_bg": min_bg,
        "max_bg": max_bg,
        "total_carbs": total_carbs,
        "total_insulin": total_insulin,
        "tir": tir,
    }


# ---------- helper: hit test in pixels ----------
def _hit_test_pixels(ax, xdata_list, ydata_list, event, tol_px=6) -> Optional[int]:
    """
    Manual hit test: transform data coords to display coords and compute pixel distance.
    Returns index of first point within tol_px, or None.
    """
    if not xdata_list:
        return None
    trans = ax.transData
    pts = []
    for x, y in zip(xdata_list, ydata_list):
        if hasattr(x, "timetuple"):
            xn = mdates.date2num(x)
        else:
            xn = x
        px, py = trans.transform((xn, y))
        pts.append((px, py))
    ex, ey = event.x, event.y
    best_idx = None
    best_dist2 = tol_px * tol_px
    for i, (px, py) in enumerate(pts):
        dx = px - ex
        dy = py - ey
        d2 = dx * dx + dy * dy
        if d2 <= best_dist2:
            best_idx = i
            best_dist2 = d2
    return best_idx


def build_overview_layers(fig, events):
    fig.clear()

    gs = fig.add_gridspec(2, 1, height_ratios=[2, 1], hspace=0.08)
    ax_top = fig.add_subplot(gs[0])
    ax_bottom = fig.add_subplot(gs[1], sharex=ax_top)
    ax_bottom_right = ax_bottom.twinx()

    bg = [e for e in events if e.kind == "GLUCOSE"]
    iob = [e for e in events if e.kind == "IOB"]
    cob = [e for e in events if e.kind == "COB"]
    pred = [e for e in events if e.kind == "RESULT"]
    smb = [e for e in events if e.kind == "SMB"]
    bolus = [e for e in events if e.kind == "BOLUS"]
    carbs = [e for e in events if e.kind == "CARBS"]

    layers: Dict[str, Any] = {}

    if not bg:
        ax_top.set_title("No BG data")
        _setup_time_axis(ax_top, "BG (mmol/L)")
        _setup_time_axis(ax_bottom, "IOB / COB")
        fig.tight_layout()
        enable_zoom(fig)
        enable_pan(fig)
        return layers

    # BG arrays (datetime and mmol)
    bg_x = [_ts_to_dt(e.ts) for e in bg]
    bg_y = [_bg_to_mmol(e.data.get("glucose") or e.data.get("value")) for e in bg]

    # TIR zone
    ax_top.axhspan(TIR_LOW, TIR_HIGH, color="lightblue", alpha=0.25, zorder=0)

    # BG line
    ln_bg, = ax_top.plot(bg_x, bg_y, color="#1f77b4", linewidth=1.2, label="BG")
    layers["BG"] = ln_bg

    bg_colors = ["green" if (y is not None and TIR_LOW <= y <= TIR_HIGH) else "red" for y in bg_y]

    # --------------------------
    # SMB: own timestamp, interpolated BG for Y
    # --------------------------
    smb_objs = []
    smb_x, smb_y, smb_vals, smb_events = [], [], [], []
    smb_arrows = []  # store arrow Annotation artists for hit-testing
    for e in smb:
        ts = e.ts
        dt, bg_val = _interp_bg_at_ts(bg, ts)
        if dt is None or bg_val is None:
            continue
        smb_x.append(dt)
        smb_y.append(bg_val)
        smb_vals.append(float(e.data.get("insulin", 0.0) or 0.0))
        smb_events.append(e)

    for idx, (x, y, v) in enumerate(zip(smb_x, smb_y, smb_vals)):
        stagger = (idx % 3) * 0.12
        top = y + 0.35 + stagger
        mid = y + 0.12 + stagger
        ln = ax_top.plot([x, x], [top, mid], color="#ffd700", linewidth=2, zorder=6)
        smb_objs.extend(ln)
        # create arrow annotation and keep reference
        arr = ax_top.annotate(
            "",
            xy=(x, mid - 0.02),
            xytext=(x, top),
            arrowprops=dict(arrowstyle="-|>", color="#ffd700", lw=1.4),
            zorder=7
        )
        smb_objs.append(arr)
        smb_arrows.append(arr)
        if v >= 0.4:
            txt = ax_top.text(x, top + 0.05, f"{v:.1f}", fontsize=8, color="#ffd700", ha="center", va="bottom", zorder=8)
            smb_objs.append(txt)

    layers["SMB"] = smb_objs
    layers["SMB_ARROWS"] = smb_arrows

    # --------------------------
    # Bolus: own timestamp, interpolated BG for Y
    # --------------------------
    bol_x, bol_y, bol_txt, bol_events = [], [], [], []
    for e in bolus:
        ts = e.ts
        dt, bg_val = _interp_bg_at_ts(bg, ts)
        if dt is None or bg_val is None:
            continue
        bol_x.append(dt)
        bol_y.append(bg_val)
        val = float(e.data.get("insulin", 0.0) or 0.0)
        bol_txt.append(f"{val:.1f}U")
        bol_events.append(e)

    bolus_objs = []
    for idx, (x, y, t) in enumerate(zip(bol_x, bol_y, bol_txt)):
        stagger = (idx % 3) * 0.18
        txt = ax_top.text(x, y + 0.45 + stagger, t, fontsize=8, color="#ff8800", ha="center", va="bottom", zorder=7)
        bolus_objs.append(txt)
    layers["Bolus"] = bolus_objs

    # --------------------------
    # Carbs: own timestamp, interpolated BG for Y (star marker)
    # --------------------------
    carb_x, carb_y, carb_txt, carb_events = [], [], [], []
    for e in carbs:
        ts = e.ts
        dt, bg_val = _interp_bg_at_ts(bg, ts)
        if dt is None or bg_val is None:
            continue
        carb_x.append(dt)
        carb_y.append(bg_val)
        carb_txt.append(f"{int(e.data.get('carbs', 0))}g")
        carb_events.append(e)

    carbs_objs = []
    for idx, (x, y, t) in enumerate(zip(carb_x, carb_y, carb_txt)):
        stagger = (idx % 3) * 0.18
        txt = ax_top.text(x, y - 0.55 - stagger, t, fontsize=8, color="black", ha="center", va="top", zorder=6)
        carbs_objs.append(txt)
    layers["Carbs"] = carbs_objs

    # Create pickable/hoverable scatters (after annotations)
    sc_bg = ax_top.scatter(bg_x, bg_y, c=bg_colors, s=40, edgecolors="black", linewidths=0.3, zorder=40)
    layers["BG_POINTS"] = sc_bg

    sc_smb = ax_top.scatter(smb_x, smb_y, s=140, facecolors='none', edgecolors='none', alpha=0.01, zorder=50)
    layers["SMB_SCATTER"] = sc_smb

    sc_bolus = None
    if bol_x:
        sc_bolus = ax_top.scatter(bol_x, bol_y, color="#ff8800", s=140, marker="v", edgecolors="black", linewidths=0.7, zorder=46)

    sc_carbs = None
    if carb_x:
        sc_carbs = ax_top.scatter(carb_x, carb_y, color="#ffeb3b", edgecolors="black", s=120, marker="*", zorder=45)

    ax_top.set_title("BG / Carbs / SMB / Bolus")
    _setup_time_axis(ax_top, "BG (mmol/L)")

    # PredBG / IOB / COB (bottom)
    if pred:
        pred_x = []
        pred_y = []
        for e in pred:
            dt = _ts_to_dt(e.ts)
            predBGs = e.data.get("predBGs")
            if predBGs and "IOB" in predBGs:
                v = predBGs["IOB"][0]
                pred_x.append(dt)
                pred_y.append(_bg_to_mmol(v))
            else:
                pred_x.append(dt)
                pred_y.append(None)
        ln_pred, = ax_bottom.plot(pred_x, pred_y, color="green", linestyle="--", label="PredBG")
        layers["PredBG"] = ln_pred
    else:
        layers["PredBG"] = ax_bottom.plot([], [])[0]

    if iob:
        iob_x = [_ts_to_dt(e.ts) for e in iob]
        iob_y = [e.data.get("iob") for e in iob]
        ln_iob, = ax_bottom.plot(iob_x, iob_y, color="#2ca02c", label="IOB")
        layers["IOB"] = ln_iob
    else:
        layers["IOB"] = ax_bottom.plot([], [])[0]

    if cob:
        cob_x = [_ts_to_dt(e.ts) for e in cob]
        cob_y = [e.data.get("cob") for e in cob]
        ln_cob, = ax_bottom_right.plot(cob_x, cob_y, color="#ff7f0e", label="COB")
        layers["COB"] = ln_cob
    else:
        layers["COB"] = ax_bottom_right.plot([], [])[0]

    ax_bottom.set_title("PredBG / IOB / COB / UAM")
    _setup_time_axis(ax_bottom, "IOB (U)")
    ax_bottom_right.set_ylabel("COB (g)")

    # UAM highlight
    uam_segments = _detect_uam_segments(bg, carbs)
    for start_ts, end_ts in uam_segments:
        ax_bottom.axvspan(_ts_to_dt(start_ts), _ts_to_dt(end_ts), color="red", alpha=0.12, zorder=0)

    # Statistics on the right: use tight_layout + subplots_adjust to avoid warning
    stats = _compute_stats(bg, carbs, smb, bolus)
    lines = []
    if stats["avg_bg"] is not None:
        lines.append(f"Avg BG: {stats['avg_bg']:.1f} mmol/L")
    if stats["min_bg"] is not None and stats["max_bg"] is not None:
        lines.append(f"Min BG: {stats['min_bg']:.1f}")
        lines.append(f"Max BG: {stats['max_bg']:.1f}")
    lines.append(f"Total carbs: {stats['total_carbs']:.0f} g")
    lines.append(f"Total insulin: {stats['total_insulin']:.2f} U")
    if stats["tir"] is not None:
        lines.append(f"TIR {TIR_LOW:.1f}–{TIR_HIGH:.1f}: {stats['tir']:.1f}%")

    text = "\n".join(lines)
    fig.tight_layout()
    fig.subplots_adjust(right=0.78)
    fig.text(0.82, 0.95, text, transform=fig.transFigure, va="top", ha="left", fontsize=9,
             bbox=dict(boxstyle="round", facecolor="white", alpha=0.95))

    # --------------------------
    # Tooltips: single AnnotationBbox + TextArea per type; update via motion hit-test
    # --------------------------
    bg_ab, bg_ta = _make_tooltip(ax_top, "")
    smb_ab, smb_ta = _make_tooltip(ax_top, "")
    bolus_ab, bolus_ta = _make_tooltip(ax_top, "")
    carb_ab, carb_ta = _make_tooltip(ax_top, "")

    # Keep TextArea references in mutable dicts to avoid local rebind issues
    bg_ta_box = {"ta": bg_ta}
    smb_ta_box = {"ta": smb_ta}
    bolus_ta_box = {"ta": bolus_ta}
    carb_ta_box = {"ta": carb_ta}

    for ab in (bg_ab, smb_ab, bolus_ab, carb_ab):
        ab.set_zorder(200)

    def _find_near_event_value(events_list, ts, window_ms=150000):
        for e in events_list:
            if abs(e.ts - ts) <= window_ms:
                if e.kind == "IOB":
                    return e.data.get("iob")
                if e.kind == "COB":
                    return e.data.get("cob")
                if e.kind == "SMB":
                    return e.data.get("insulin")
                if e.kind == "BOLUS":
                    return e.data.get("insulin")
                if e.kind == "CARBS":
                    return e.data.get("carbs")
        return None

    def _update_textarea_box(box: Dict[str, TextArea], ab: AnnotationBbox, text: str):
        """
        Update TextArea stored in box safely. If update fails, replace ab.offsetbox and update box['ta'].
        """
        try:
            child = box["ta"].get_children()[0]
            child.set_text(text)
            return box["ta"]
        except Exception:
            new_ta = TextArea(text)
            ab.offsetbox = new_ta
            box["ta"] = new_ta
            return new_ta

    # motion handler: use manual pixel hit-test for hover
    def on_motion(event):
        if event.inaxes != ax_top:
            changed = False
            for ab in (bg_ab, smb_ab, bolus_ab, carb_ab):
                if ab.get_visible():
                    ab.set_visible(False)
                    changed = True
            if changed and getattr(event, "canvas", None) is not None:
                event.canvas.draw_idle()
            return

        # BG hover (обновлённый: НЕ включает SMB)
        idx_bg = _hit_test_pixels(ax_top, bg_x, bg_y, event, tol_px=6)
        if idx_bg is not None:
            ts = bg[idx_bg].ts
            dt = _ts_to_dt(ts).strftime("%d.%m %H:%M:%S")
            bg_val = bg_y[idx_bg]
            iob_val = _find_near_event_value(iob, ts)
            cob_val = _find_near_event_value(cob, ts)
            bol_val = _find_near_event_value(bolus, ts)
            carb_val = _find_near_event_value(carbs, ts)

            # Собираем текст: SMB здесь НЕ упоминается
            text = f"{dt}\nBG: {bg_val:.1f} mmol/L"
            if iob_val is not None:
                text += f"\nIOB: {iob_val:.2f} U"
            if cob_val is not None:
                text += f"\nCOB: {int(cob_val)} g"
            if bol_val is not None:
                text += f"\nBolus: {bol_val:.2f} U"
            if carb_val is not None:
                text += f"\nCarbs: {int(carb_val)} g"

            _update_textarea_box(bg_ta_box, bg_ab, text)
            bg_ab.xy = (bg_x[idx_bg], bg_y[idx_bg])
            bg_ab.set_visible(True)
            smb_ab.set_visible(False)
            bolus_ab.set_visible(False)
            carb_ab.set_visible(False)
            if getattr(event, "canvas", None) is not None:
                event.canvas.draw_idle()
            return
        else:
            if bg_ab.get_visible():
                bg_ab.set_visible(False)


        # SMB hover: first try arrow bbox hit-test (preferred), then fallback to point hit-test
        renderer = None
        try:
            renderer = event.canvas.get_renderer()
        except Exception:
            renderer = None

        smb_hit = None
        # check arrow annotations' bbox (if renderer available)
        if renderer is not None and smb_arrows:
            for i, arr in enumerate(smb_arrows):
                try:
                    bbox = arr.get_window_extent(renderer)
                    # inflate bbox by a few pixels for easier hover
                    pad = 6
                    x0, y0 = bbox.x0 - pad, bbox.y0 - pad
                    x1, y1 = bbox.x1 + pad, bbox.y1 + pad
                    if x0 <= event.x <= x1 and y0 <= event.y <= y1:
                        smb_hit = i
                        break
                except Exception:
                    continue

        # fallback: pixel hit-test on smb points
        if smb_hit is None:
            smb_hit = _hit_test_pixels(ax_top, smb_x, smb_y, event, tol_px=8)

        if smb_hit is not None:
            ts = smb_events[smb_hit].ts
            dt = _ts_to_dt(ts).strftime("%d.%m %H:%M:%S")
            v = smb_vals[smb_hit]
            text = f"{dt}\nSMB: {v:.2f} U"
            _update_textarea_box(smb_ta_box, smb_ab, text)
            smb_ab.xy = (smb_x[smb_hit], smb_y[smb_hit])
            smb_ab.set_visible(True)
            bg_ab.set_visible(False)
            bolus_ab.set_visible(False)
            carb_ab.set_visible(False)
            if getattr(event, "canvas", None) is not None:
                event.canvas.draw_idle()
            return
        else:
            if smb_ab.get_visible():
                smb_ab.set_visible(False)

        # Bolus hover
        idx_bol = _hit_test_pixels(ax_top, bol_x, bol_y, event, tol_px=8) if bol_x else None
        if idx_bol is not None:
            ts = bol_events[idx_bol].ts
            dt = _ts_to_dt(ts).strftime("%d.%m %H:%M:%S")
            v = float(bol_events[idx_bol].data.get("insulin", 0.0) or 0.0)
            text = f"{dt}\nBolus: {v:.2f} U"
            _update_textarea_box(bolus_ta_box, bolus_ab, text)
            bolus_ab.xy = (bol_x[idx_bol], bol_y[idx_bol])
            bolus_ab.set_visible(True)
            bg_ab.set_visible(False)
            smb_ab.set_visible(False)
            carb_ab.set_visible(False)
            if getattr(event, "canvas", None) is not None:
                event.canvas.draw_idle()
            return
        else:
            if bolus_ab.get_visible():
                bolus_ab.set_visible(False)

        # Carbs hover
        idx_carb = _hit_test_pixels(ax_top, carb_x, carb_y, event, tol_px=8) if carb_x else None
        if idx_carb is not None:
            ts = carb_events[idx_carb].ts
            dt = _ts_to_dt(ts).strftime("%d.%m %H:%M:%S")
            v = int(carb_events[idx_carb].data.get("carbs", 0) or 0)
            text = f"{dt}\nCarbs: {v} g"
            _update_textarea_box(carb_ta_box, carb_ab, text)
            carb_ab.xy = (carb_x[idx_carb], carb_y[idx_carb])
            carb_ab.set_visible(True)
            bg_ab.set_visible(False)
            smb_ab.set_visible(False)
            bolus_ab.set_visible(False)
            if getattr(event, "canvas", None) is not None:
                event.canvas.draw_idle()
            return
        else:
            if carb_ab.get_visible():
                carb_ab.set_visible(False)

    fig.canvas.mpl_connect("motion_notify_event", on_motion)

    # Zoom and pan
    enable_zoom(fig)
    enable_pan(fig)

    return layers


def enable_zoom(fig):
    def on_scroll(event):
        ax = event.inaxes
        if ax is None:
            return

        base = 1.2
        scale = 1 / base if event.button == 'up' else base

        xdata = event.xdata
        ydata = event.ydata
        if xdata is None or ydata is None:
            return

        x_left, x_right = ax.get_xlim()
        y_bottom, y_top = ax.get_ylim()

        ax.set_xlim([xdata - (xdata - x_left) * scale, xdata + (x_right - xdata) * scale])
        ax.set_ylim([ydata - (ydata - y_bottom) * scale, ydata + (y_top - ydata) * scale])

        if getattr(event, "canvas", None) is not None:
            event.canvas.draw_idle()

    fig.canvas.mpl_connect("scroll_event", on_scroll)


def enable_pan(fig):
    pan_state = {"press": None, "xpress_pix": None, "xlim_on_press": None, "ax": None}

    def on_press(event):
        if event.button == 1 and event.inaxes:
            pan_state["press"] = True
            pan_state["xpress_pix"] = event.x
            pan_state["xlim_on_press"] = event.inaxes.get_xlim()
            pan_state["ax"] = event.inaxes

    def on_release(event):
        pan_state["press"] = None
        pan_state["xpress_pix"] = None
        pan_state["xlim_on_press"] = None
        pan_state["ax"] = None

    def on_move(event):
        if not pan_state["press"]:
            return
        if event.inaxes != pan_state["ax"]:
            return
        try:
            dx_pix = event.x - pan_state["xpress_pix"]
            ax = pan_state["ax"]
            x0, x1 = pan_state["xlim_on_press"]
            trans = ax.transData.inverted()
            p0 = trans.transform((0, 0))[0]
            p1 = trans.transform((dx_pix, 0))[0]
            dx_data = p1 - p0
            ax.set_xlim(x0 - dx_data, x1 - dx_data)
            if getattr(event, "canvas", None) is not None:
                event.canvas.draw_idle()
        except Exception:
            pass

    fig.canvas.mpl_connect('button_press_event', on_press)
    fig.canvas.mpl_connect('button_release_event', on_release)
    fig.canvas.mpl_connect('motion_notify_event', on_move)

часть 2/3 - analysis/smb_effectiveness.py
from typing import List, Dict, Any
from parser.timeline import TimelineEvent


def analyze_smb_effectiveness(events: List[TimelineEvent]) -> Dict[str, Any]:
    smb_events = [e for e in events if e.kind == "SMB"]
    bg_events = [e for e in events if e.kind == "BG"]

    if not smb_events or not bg_events:
        return {"count": 0, "avg_delta_per_unit": 0.0, "points": []}

    def find_bg_at(ts_target: int):
        best = None
        best_dt = None
        for bg in bg_events:
            dt = abs(bg.ts - ts_target)
            if best is None or dt < best_dt:
                best = bg
                best_dt = dt
        return best

    points = []
    deltas = []

    for smb in smb_events:
        ins = smb.data.get("insulin")
        if not ins or ins <= 0:
            continue

        bg_before = find_bg_at(smb.ts)
        bg_after = find_bg_at(smb.ts + 60 * 60 * 1000)

        if not bg_before or not bg_after:
            continue

        v_before = bg_before.data.get("glucose") or bg_before.data.get("value")
        v_after = bg_after.data.get("glucose") or bg_after.data.get("value")
        if v_before is None or v_after is None:
            continue

        delta = v_after - v_before
        per_unit = delta / ins
        deltas.append(per_unit)

        points.append({
            "timestamp": smb.ts,
            "delta_per_unit": per_unit,
        })

    if not deltas:
        return {"count": 0, "avg_delta_per_unit": 0.0, "points": []}

    avg = sum(deltas) / len(deltas)
    return {"count": len(deltas), "avg_delta_per_unit": avg, "points": points}

часть 2/3 - data/aps_log.zip

часть 2/3 - emulator/cycle_model.py
from dataclasses import dataclass
from core.glucose import GlucoseData
from core.profile import ProfileData
from core.autoisf import AutoISFData
from core.iob import IOBData


@dataclass
class CycleInput:
    glucose: dict | None
    profile: dict | None
    autosens: None = None
    autoisf: float | None = None
    iob: dict | None = None
    cob: float | None = None
    predictions: dict | None = None

    def to_core(self):
        g = GlucoseData(self.glucose) if self.glucose else None
        p = ProfileData(self.profile) if self.profile else None
        ai = AutoISFData(self.autoisf) if self.autoisf is not None else None
        iob = IOBData(self.iob) if self.iob else None
        return g, p, ai, iob

emulator/determine_basal.py
from core.suggested import SuggestedData
from core.predictions import PredictionsData


class DetermineBasalEngine:
    """
    Эмулятор, учитывающий predBGs.
    Работает с CycleInput.to_core() + predictions.
    """

    def __init__(self, max_basal=5.0, min_temp_duration=30):
        self.max_basal = max_basal
        self.min_temp_duration = min_temp_duration

    def compute_from_input(self, ci):
        g, p, autoisf, iob = ci.to_core()
        pred = PredictionsData(ci.predictions)

        if not g or not p:
            return None

        # 1) ISF
        isf = p.sens
        if autoisf and autoisf.factor:
            isf = p.sens * autoisf.factor

        # 2) deviation по текущему BG
        deviation = g.glucose - p.target_bg

        # 3) insulinReq по BG
        insulin_bg = deviation / isf if isf else 0

        # 4) insulinReq по предсказаниям
        insulin_pred = 0
        pred_dev = 0
        if pred.min_pred():
            pred_dev = pred.min_pred() - p.target_bg
            insulin_pred = pred_dev / isf if isf else 0

        # 5) итог
        insulinReq = max(0, insulin_bg + insulin_pred)

        # 6) temp basal
        rate = min(self.max_basal, insulinReq * 2)
        duration = self.min_temp_duration

        reason = (
            f"[EMU] BGdev={deviation:.1f}, PredDev={pred_dev:.1f}, "
            f"ISF={isf}, insulinReq={insulinReq:.3f}"
        )

        return SuggestedData({
            "insulinReq": round(insulinReq, 3),
            "rate": round(rate, 3),
            "duration": duration,
            "reason": reason
        })

часть 2/3 - emulator/scenario.py
from copy import deepcopy
from .determine_basal import DetermineBasalEngine


def run_scenario_change_isf(cycle_input, new_isf: float):
    ci = deepcopy(cycle_input)
    ci.profile["sens"] = new_isf
    engine = DetermineBasalEngine()
    return engine.compute_from_input(ci)


def run_scenario_change_target(cycle_input, new_target: float):
    ci = deepcopy(cycle_input)
    ci.profile["target_bg"] = new_target
    engine = DetermineBasalEngine()
    return engine.compute_from_input(ci)


def run_scenario_change_max_basal(cycle_input, max_basal: float):
    ci = deepcopy(cycle_input)
    engine = DetermineBasalEngine(max_basal=max_basal)
    return engine.compute_from_input(ci)


часть 2/3 - gui/dashboard.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QComboBox, QCheckBox, QFrame
)
from PyQt6.QtCore import Qt

import matplotlib

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
from matplotlib.figure import Figure

from parser.timeline import TimelineBuilder
from analysis.plots import build_overview_layers


class Dashboard(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AAPS Emulator Dashboard (UTC)")
        self.setGeometry(200, 200, 1200, 800)

        main_layout = QHBoxLayout()
        left_panel = QVBoxLayout()
        right_panel = QVBoxLayout()

        self.label = QLabel("AAPS Dashboard (UTC)", self)
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        left_panel.addWidget(self.label)

        btn_load = QPushButton("Load logs")
        btn_load.clicked.connect(self.load_logs)
        left_panel.addWidget(btn_load)

        self.time_filter = QComboBox()
        self.time_filter.addItems(["all", "night", "morning", "day", "evening"])
        left_panel.addWidget(self.time_filter)

        btn_overview = QPushButton("Build overview")
        btn_overview.clicked.connect(self.update_plot)
        left_panel.addWidget(btn_overview)

        sep = QFrame()
        sep.setFrameShape(QFrame.Shape.HLine)
        sep.setFrameShadow(QFrame.Shadow.Sunken)
        left_panel.addWidget(sep)

        self.cb_bg = QCheckBox("BG")
        self.cb_pred = QCheckBox("PredBG")
        self.cb_iob = QCheckBox("IOB")
        self.cb_cob = QCheckBox("COB")
        self.cb_smb = QCheckBox("SMB")
        self.cb_bolus = QCheckBox("Bolus")
        self.cb_carbs = QCheckBox("Carbs")

        for cb in [
            self.cb_bg, self.cb_pred, self.cb_iob, self.cb_cob,
            self.cb_smb, self.cb_bolus, self.cb_carbs
        ]:
            cb.setChecked(True)
            cb.stateChanged.connect(self.update_plot)
            left_panel.addWidget(cb)

        left_panel.addStretch()
        
        self.btn_reset = QPushButton("Reset view")
        self.btn_reset.clicked.connect(self.update_plot)
        right_panel.addWidget(self.btn_reset)


        self.fig = Figure(figsize=(10, 6))
        self.canvas = FigureCanvas(self.fig)
        right_panel.addWidget(self.canvas)

        self.toolbar = NavigationToolbar2QT(self.canvas, self)
        right_panel.addWidget(self.toolbar)

        main_layout.addLayout(left_panel, 1)
        main_layout.addLayout(right_panel, 4)

        self.setLayout(main_layout)

        self.events = []
        self.layers = {}

    def load_logs(self):
        tb = TimelineBuilder("data")
        self.events = tb.build_timeline()
        self.label.setText(f"Loaded events: {len(self.events)}")

    def filter_events(self):
        mode = self.time_filter.currentText()
        if mode == "all":
            return self.events

        from datetime import datetime, timezone

        def tod(ts):
            dt = datetime.fromtimestamp(ts / 1000, tz=timezone.utc)
            h = dt.hour
            if 0 <= h < 6:
                return "night"
            if 6 <= h < 12:
                return "morning"
            if 12 <= h < 18:
                return "day"
            return "evening"

        return [e for e in self.events if tod(e.ts) == mode]

    def update_plot(self):
        if not self.events:
            return

        ev = self.filter_events()

        self.layers = build_overview_layers(self.fig, ev)
        self.apply_visibility()
        self.canvas.draw()

    def apply_visibility(self):
        if not self.layers:
            return

        self.layers["BG"].set_visible(self.cb_bg.isChecked())
        self.layers["PredBG"].set_visible(self.cb_pred.isChecked())
        self.layers["IOB"].set_visible(self.cb_iob.isChecked())
        self.layers["COB"].set_visible(self.cb_cob.isChecked())

        for obj in self.layers["SMB"]:
            obj.set_visible(self.cb_smb.isChecked())

        for obj in self.layers["Bolus"]:
            obj.set_visible(self.cb_bolus.isChecked())

        for obj in self.layers["Carbs"]:
            obj.set_visible(self.cb_carbs.isChecked())


def run_dashboard():
    app = QApplication(sys.argv)
    gui = Dashboard()
    gui.show()
    sys.exit(app.exec())

часть 3/3 - parser/file_loader.py
import os
import gzip
import zipfile


class LogFileLoader:
    """
    Универсальный загрузчик:
    - читает ZIP с любым именем
    - читает все файлы внутри ZIP
    - читает любые .txt, .log, .gz
    - читает любые файлы, содержащие APS-данные
    """

    def __init__(self, folder: str):
        self.folder = folder

    def iter_log_files(self):
        """
        Возвращает ВСЕ файлы:
        - любые ZIP
        - любые .txt, .log, .gz
        - любые файлы внутри ZIP
        """
        for root, _, files in os.walk(self.folder):
            for name in files:
                path = os.path.join(root, name)

                # ZIP — читаем всегда
                if name.lower().endswith(".zip"):
                    yield ("zip", path)
                    continue

                # любые текстовые файлы
                if (
                    name.lower().endswith(".txt")
                    or name.lower().endswith(".log")
                    or name.lower().endswith(".gz")
                    or ".log" in name.lower()  # AndroidAPS.2026-01-14.0.log
                    or ".txt" in name.lower()  # странные имена типа "[.txt"
                ):
                    yield ("file", path)

    def iter_log_lines(self):
        """
        Возвращает строки из всех файлов.
        """
        for ftype, path in self.iter_log_files():

            # -----------------------------
            # ZIP-файл — читаем ВСЁ внутри
            # -----------------------------
            if ftype == "zip":
                try:
                    with zipfile.ZipFile(path, "r") as z:
                        for fname in z.namelist():
                            # читаем любые файлы внутри ZIP
                            with z.open(fname, "r") as f:
                                try:
                                    for line in f:
                                        yield line.decode("utf-8", errors="ignore").strip()
                                except Exception:
                                    pass
                except Exception as e:
                    print(f"[ZIP ERROR] {path}: {e}")
                continue

            # -----------------------------
            # Обычный файл
            # -----------------------------
            if path.endswith(".gz"):
                opener = gzip.open
                mode = "rt"
            else:
                opener = open
                mode = "r"

            try:
                with opener(path, mode, encoding="utf-8", errors="ignore") as f:
                    for line in f:
                        yield line.strip()
            except Exception as e:
                print(f"[FILE ERROR] {path}: {e}")


часть 3/3 - parser/timeline.py
import os
from typing import List
from parser.log_parser_json import AAPS34JSONParser


class TimelineEvent:
    def __init__(self, ts: int, kind: str, data: dict, raw: str):
        self.ts = ts
        self.kind = kind
        self.data = data
        self.raw = raw


class TimelineBuilder:
    def __init__(self, folder: str):
        self.folder = folder
        self.parser = AAPS34JSONParser()

    def _safe_ts(self, ts):
        """Приводим timestamp к int, если возможно."""
        if ts is None:
            return None
        if isinstance(ts, (int, float)):
            return int(ts)
        if isinstance(ts, str):
            # если строка — пробуем преобразовать
            if ts.isdigit():
                return int(ts)
            # ISO8601?
            try:
                return self.parser._parse_iso8601(ts)
            except:
                return None
        return None

    def build_timeline(self) -> List[TimelineEvent]:
        events: List[TimelineEvent] = []

        for root, _, files in os.walk(self.folder):
            for fn in files:
                if not fn.lower().endswith((".txt", ".log")):
                    continue

                path = os.path.join(root, fn)
                try:
                    with open(path, "r", encoding="utf-8", errors="ignore") as f:
                        for line in f:
                            fs = self.parser.fast_scan(line)
                            if not fs:
                                continue

                            # BG
                            if "glucose" in fs and isinstance(fs["glucose"], dict):
                                ts = self._safe_ts(
                                    self.parser.extract_timestamp_from_json(fs["glucose"])
                                )
                                if ts:
                                    events.append(TimelineEvent(ts, "GLUCOSE", fs["glucose"], line))

                            # IOB
                            if "iob" in fs and isinstance(fs["iob"], dict):
                                ts = self._safe_ts(
                                    self.parser.extract_timestamp_from_json(fs["iob"])
                                )
                                if ts:
                                    events.append(TimelineEvent(ts, "IOB", fs["iob"], line))

                            # COB
                            if "cob" in fs and isinstance(fs["cob"], dict):
                                ts = self._safe_ts(fs["cob"].get("timestamp"))
                                if ts:
                                    events.append(TimelineEvent(ts, "COB", fs["cob"], line))

                            # RESULT
                            if "result" in fs and isinstance(fs["result"], dict):
                                ts = self._safe_ts(
                                    self.parser.extract_timestamp_from_json(fs["result"])
                                )
                                if ts:
                                    events.append(TimelineEvent(ts, "RESULT", fs["result"], line))

                            # SMB / BOLUS / CARBS
                            for k in ("smb", "bolus", "carbs"):
                                if k in fs and isinstance(fs[k], dict):
                                    ts = self._safe_ts(fs[k].get("timestamp"))
                                    if ts:
                                        events.append(TimelineEvent(ts, k.upper(), fs[k], line))

                except Exception as e:
                    print("Error reading", path, e)

        # теперь ts гарантированно int → сортировка безопасна
        events.sort(key=lambda e: e.ts)
        return events

часть 3/3 - parser/log_parser_json.py
import json
import re
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional


class AAPS34JSONParser:

    # --------------------------
    # JSON extraction
    # --------------------------

    def _extract_json_after_key(self, line: str, key: str):
        idx = line.find(key)
        if idx == -1:
            return None

        start = None
        for ch in ["{", "["]:
            pos = line.find(ch, idx)
            if pos != -1:
                start = pos if start is None else min(start, pos)

        if start is None:
            return None

        opening = line[start]
        closing = "}" if opening == "{" else "]"

        depth = 0
        for i in range(start, len(line)):
            if line[i] == opening:
                depth += 1
            elif line[i] == closing:
                depth -= 1
                if depth == 0:
                    raw = line[start:i + 1]
                    try:
                        return json.loads(raw)
                    except:
                        return None
        return None

    def _ensure_dict(self, js):
        if js is None:
            return None
        if isinstance(js, dict):
            return js
        if isinstance(js, list) and js and isinstance(js[0], dict):
            return js[0]
        return None

    # --------------------------
    # ISO8601 → UTC
    # --------------------------

    def _parse_iso8601(self, value: str) -> Optional[int]:
        try:
            dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
            return int(dt.timestamp() * 1000)
        except:
            return None

    # --------------------------
    # USER ENTRY (локальное → UTC)
    # --------------------------

    def _parse_user_entry_datetime(self, line: str) -> Optional[int]:
        m = re.search(r"USER ENTRY:\s+(\d{2}\.\d{2}\.\d{4}) (\d{2}:\d{2}:\d{2})", line)
        if not m:
            return None

        date_str, time_str = m.group(1), m.group(2)
        local_dt = datetime.strptime(f"{date_str} {time_str}", "%d.%m.%Y %H:%M:%S")

        m2 = re.search(r"utcOffset=(\d+)", line)
        offset_ms = int(m2.group(1)) if m2 else 0

        utc_dt = local_dt - timedelta(milliseconds=offset_ms)
        return int(utc_dt.timestamp() * 1000)

    # --------------------------
    # JSON timestamp extraction
    # --------------------------

    def extract_timestamp_from_json(self, js: Dict[str, Any]) -> Optional[int]:
        if "timestamp" in js and isinstance(js["timestamp"], (int, float)):
            return int(js["timestamp"])

        if "timestamp" in js and isinstance(js["timestamp"], str):
            try:
                dt = datetime.fromisoformat(js["timestamp"].replace("Z", "+00:00"))
                return int(dt.timestamp() * 1000)
            except:
                pass

        for key in ("date", "time"):
            if key in js:
                try:
                    return int(js[key])
                except:
                    pass

        return None

    # --------------------------
    # JSON BLOCK PARSERS
    # --------------------------

    def parse_glucose_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "glucoseStatusJson"))

    def parse_iob_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "iobDataJson"))

    def parse_result_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "resultJson"))

    def parse_suggested_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "suggested"))

    def parse_autosens_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "autosensDataJson"))

    def parse_meal_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "mealDataJson"))

    # --------------------------
    # USER ENTRY EVENTS
    # --------------------------

    def parse_user_entry_events(self, line: str) -> List[Dict[str, Any]]:
        if "USER ENTRY:" not in line:
            return []

        m_ts = re.search(r"Timestamp\(value=(\d+)\)", line)
        if m_ts:
            ts = int(m_ts.group(1))
        else:
            ts = self._parse_user_entry_datetime(line)

        if ts is None:
            return []

        events = []

        # CARBS — игнорируем CarbDialog (дубль)
        if " CARBS " in line and "Gram(value=" in line:

            if "CarbDialog" in line:
                return []  # ← ключевой фикс

            m = re.search(r"Gram\(value=([\d\.]+)\)", line)
            if m:
                events.append({
                    "kind": "CARBS",
                    "timestamp": ts,
                    "carbs": float(m.group(1))
                })

        # SMB
        if " SMB " in line and "Insulin(value=" in line:
            m = re.search(r"Insulin\(value=([\d\.]+)\)", line)
            if m:
                events.append({
                    "kind": "SMB",
                    "timestamp": ts,
                    "insulin": float(m.group(1))
                })

        # BOLUS WIZARD (без CARBS!)
        if "BOLUS_WIZARD" in line:
            m_ins = re.search(r"Insulin\(value=([\d\.]+)\)", line)
            if m_ins:
                events.append({
                    "kind": "BOLUS",
                    "timestamp": ts,
                    "insulin": float(m_ins.group(1))
                })

        return events

    # --------------------------
    # FAST SCAN
    # --------------------------

    def fast_scan(self, line: str) -> Dict[str, Any]:
        out: Dict[str, Any] = {}

        # BG
        if "glucoseStatusJson" in line:
            out["glucose"] = self.parse_glucose_json(line)

        # IOB
        if "iobDataJson" in line:
            out["iob"] = self.parse_iob_json(line)

        # RESULT
        if "resultJson" in line:
            js = self.parse_result_json(line)
            out["result"] = js
            if js and "cob" in js:
                out["cob"] = {
                    "cob": js["cob"],
                    "timestamp": js.get("timestamp")
                }

        # SUGGESTED (главный источник COB)
        if "suggested={" in line:
            js = self.parse_suggested_json(line)
            out["suggested"] = js
            if js and "COB" in js:
                out["cob"] = {
                    "cob": js["COB"],
                    "timestamp": js.get("timestamp")
                }

        # AUTOSENS
        if "autosensDataJson" in line:
            js = self.parse_autosens_json(line)
            out["autosens"] = js
            if js and "cob" in js:
                out["cob"] = {
                    "cob": js["cob"],
                    "timestamp": js.get("timestamp")
                }

        # MEAL
        if "mealDataJson" in line:
            js = self.parse_meal_json(line)
            out["meal"] = js
            if js and ("mealCOB" in js or "cob" in js):
                out["cob"] = {
                    "cob": js.get("mealCOB") or js.get("cob"),
                    "timestamp": js.get("timestamp")
                }

        # USER ENTRY
        ue = self.parse_user_entry_events(line) or []
        for ev in ue:
            out[ev["kind"].lower()] = ev

        return out

