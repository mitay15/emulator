gui/dashboard.py
import sys
from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QComboBox, QCheckBox, QFrame
)
from PyQt6.QtCore import Qt

import matplotlib
matplotlib.rcParams['timezone'] = 'UTC'

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
from matplotlib.figure import Figure

from parser.timeline import TimelineBuilder
from analysis.plots import build_overview_layers


class Dashboard(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AAPS Emulator Dashboard")
        self.setGeometry(200, 200, 1200, 800)

        main_layout = QHBoxLayout()
        left_panel = QVBoxLayout()
        right_panel = QVBoxLayout()

        self.label = QLabel("AAPS Dashboard", self)
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        left_panel.addWidget(self.label)

        btn_load = QPushButton("Загрузить логи")
        btn_load.clicked.connect(self.load_logs)
        left_panel.addWidget(btn_load)

        self.time_filter = QComboBox()
        self.time_filter.addItems(["all", "night", "morning", "day", "evening"])
        left_panel.addWidget(self.time_filter)

        btn_overview = QPushButton("Построить общий график")
        btn_overview.clicked.connect(self.update_plot)
        left_panel.addWidget(btn_overview)

        sep = QFrame()
        sep.setFrameShape(QFrame.Shape.HLine)
        sep.setFrameShadow(QFrame.Shadow.Sunken)
        left_panel.addWidget(sep)

        self.cb_bg = QCheckBox("BG")
        self.cb_pred = QCheckBox("PredBG")
        self.cb_iob = QCheckBox("IOB")
        self.cb_cob = QCheckBox("COB")
        self.cb_smb = QCheckBox("SMB")
        self.cb_bolus = QCheckBox("Bolus")
        self.cb_carbs = QCheckBox("Carbs")

        for cb in [
            self.cb_bg, self.cb_pred, self.cb_iob, self.cb_cob,
            self.cb_smb, self.cb_bolus, self.cb_carbs
        ]:
            cb.setChecked(True)
            cb.stateChanged.connect(self.update_plot)
            left_panel.addWidget(cb)

        left_panel.addStretch()

        self.fig = Figure(figsize=(10, 6))
        self.canvas = FigureCanvas(self.fig)
        right_panel.addWidget(self.canvas)

        self.toolbar = NavigationToolbar2QT(self.canvas, self)
        right_panel.addWidget(self.toolbar)

        main_layout.addLayout(left_panel, 1)
        main_layout.addLayout(right_panel, 4)

        self.setLayout(main_layout)

        self.events = []
        self.layers = {}

    def load_logs(self):
        tb = TimelineBuilder("data")
        self.events = tb.build_timeline()
        self.label.setText(f"Загружено событий: {len(self.events)}")

    def filter_events(self):
        mode = self.time_filter.currentText()
        if mode == "all":
            return self.events

        from datetime import datetime

        def tod(ts):
            dt = datetime.utcfromtimestamp(ts / 1000)
            h = dt.hour
            if 0 <= h < 6:
                return "night"
            if 6 <= h < 12:
                return "morning"
            if 12 <= h < 18:
                return "day"
            return "evening"

        return [e for e in self.events if tod(e.ts) == mode]

    def update_plot(self):
        if not self.events:
            return

        ev = self.filter_events()

        self.layers = build_overview_layers(self.fig, ev)
        self.apply_visibility()
        self.canvas.draw()

    def apply_visibility(self):
        if not self.layers:
            return

        self.layers["BG"].set_visible(self.cb_bg.isChecked())
        self.layers["PredBG"].set_visible(self.cb_pred.isChecked())
        self.layers["IOB"].set_visible(self.cb_iob.isChecked())
        self.layers["COB"].set_visible(self.cb_cob.isChecked())

        for obj in self.layers["SMB"]:
            obj.set_visible(self.cb_smb.isChecked())

        for obj in self.layers["Bolus"]:
            obj.set_visible(self.cb_bolus.isChecked())

        for obj in self.layers["Carbs"]:
            obj.set_visible(self.cb_carbs.isChecked())


def run_dashboard():
    app = QApplication(sys.argv)
    gui = Dashboard()
    gui.show()
    sys.exit(app.exec())


parser/log_parser_json.py
import json
import re
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional


class AAPS34JSONParser:

    # --------------------------
    # JSON extraction
    # --------------------------

    def _extract_json_after_key(self, line: str, key: str):
        idx = line.find(key)
        if idx == -1:
            return None

        start = None
        for ch in ["{", "["]:
            pos = line.find(ch, idx)
            if pos != -1:
                start = pos if start is None else min(start, pos)

        if start is None:
            return None

        opening = line[start]
        closing = "}" if opening == "{" else "]"

        depth = 0
        for i in range(start, len(line)):
            if line[i] == opening:
                depth += 1
            elif line[i] == closing:
                depth -= 1
                if depth == 0:
                    raw = line[start:i + 1]
                    try:
                        return json.loads(raw)
                    except:
                        return None
        return None

    def _ensure_dict(self, js):
        if js is None:
            return None
        if isinstance(js, dict):
            return js
        if isinstance(js, list) and js and isinstance(js[0], dict):
            return js[0]
        return None

    # --------------------------
    # ISO8601
    # --------------------------

    def _parse_iso8601(self, value: str) -> Optional[int]:
        try:
            dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
            return int(dt.timestamp() * 1000)
        except:
            return None

    # --------------------------
    # USER ENTRY timestamp
    # --------------------------

    def _parse_user_entry_datetime(self, line: str) -> Optional[int]:
        m = re.search(r"USER ENTRY:\s+(\d{2}\.\d{2}\.\d{4}) (\d{2}:\d{2}:\d{2})", line)
        if not m:
            return None

        date_str, time_str = m.group(1), m.group(2)
        local_dt = datetime.strptime(f"{date_str} {time_str}", "%d.%m.%Y %H:%M:%S")

        m2 = re.search(r"utcOffset=(\d+)", line)
        offset_ms = int(m2.group(1)) if m2 else 10800000

        utc_dt = local_dt - timedelta(milliseconds=offset_ms)
        return int(utc_dt.timestamp() * 1000)


    # --------------------------
    # JSON timestamp extraction
    # --------------------------

    def _extract_timestamp_from_json(self, js: Dict[str, Any]) -> Optional[int]:
        # timestamp в миллисекундах
        if "timestamp" in js and isinstance(js["timestamp"], (int, float)):
            return int(js["timestamp"])

        # ISO8601
        if "timestamp" in js and isinstance(js["timestamp"], str):
            try:
                dt = datetime.fromisoformat(js["timestamp"].replace("Z", "+00:00"))
                return int(dt.timestamp() * 1000)
            except:
                pass

        # glucoseStatusJson.date
        if "date" in js:
            try:
                return int(js["date"])
            except:
                pass

        # iobDataJson.time
        if "time" in js:
            try:
                return int(js["time"])
            except:
                pass

        return None


    # --------------------------
    # JSON BLOCK PARSERS
    # --------------------------

    def parse_glucose_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "glucoseStatusJson"))

    def parse_iob_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "iobDataJson"))

    def parse_result_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "resultJson"))

    def parse_suggested_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "suggested"))

    def parse_autosens_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "autosensDataJson"))

    def parse_meal_json(self, line: str):
        return self._ensure_dict(self._extract_json_after_key(line, "mealDataJson"))

    # --------------------------
    # USER ENTRY EVENTS
    # --------------------------

    def parse_user_entry_events(self, line: str) -> List[Dict[str, Any]]:
        if "USER ENTRY:" not in line:
            return []

        ts = self._parse_user_entry_datetime(line)
        if ts is None:
            return []

        events = []

        if " CARBS " in line and "Gram(value=" in line:
            m = re.search(r"Gram\(value=([\d\.]+)\)", line)
            if m:
                events.append({"kind": "CARBS", "timestamp": ts, "carbs": float(m.group(1))})

        if " SMB " in line and "Insulin(value=" in line:
            m = re.search(r"Insulin\(value=([\d\.]+)\)", line)
            if m:
                events.append({"kind": "SMB", "timestamp": ts, "insulin": float(m.group(1))})

        if "BOLUS_WIZARD" in line:
            m_ins = re.search(r"Insulin\(value=([\d\.]+)\)", line)
            m_carb = re.search(r"Gram\(value=([\d\.]+)\)", line)
            if m_ins:
                events.append({"kind": "BOLUS", "timestamp": ts, "insulin": float(m_ins.group(1))})
            if m_carb:
                events.append({"kind": "CARBS", "timestamp": ts, "carbs": float(m_carb.group(1))})

        return events

    # --------------------------
    # FAST SCAN
    # --------------------------

    def fast_scan(self, line: str) -> Dict[str, Any]:
        out = {}

        if "glucoseStatusJson" in line:
            out["glucose"] = self.parse_glucose_json(line)

        if "iobDataJson" in line:
            out["iob"] = self.parse_iob_json(line)

        if "resultJson" in line:
            out["result"] = self.parse_result_json(line)

        if "suggested={" in line:
            out["suggested"] = self.parse_suggested_json(line)

        if "autosensDataJson" in line:
            out["autosens"] = self.parse_autosens_json(line)

        if "mealDataJson" in line:
            out["meal"] = self.parse_meal_json(line)

        # USER ENTRY
        ue = self.parse_user_entry_events(line)
        for ev in ue:
            out[ev["kind"].lower()] = ev

        return out

parser/timeline.py
from dataclasses import dataclass
from typing import List, Dict, Any, Optional

from .log_parser_json import AAPS34JSONParser
from .file_loader import LogFileLoader


@dataclass
class TimelineEvent:
    ts: int
    kind: str
    data: Dict[str, Any]
    raw_line: str


class TimelineBuilder:
    def __init__(self, folder: str):
        self.folder = folder
        self.loader = LogFileLoader(folder)
        self.parser = AAPS34JSONParser()

    def build_timeline(self) -> List[TimelineEvent]:
        events: List[TimelineEvent] = []

        for line in self.loader.iter_log_lines():
            fs = self.parser.fast_scan(line)

            def add_from_json(kind: str):
                if kind in fs and isinstance(fs[kind], dict):
                    ts = self.parser.extract_timestamp_from_json(fs[kind])
                    if ts is not None and ts > 0:
                        events.append(TimelineEvent(ts, kind.upper(), fs[kind], line))

            add_from_json("glucose")
            add_from_json("result")
            add_from_json("suggested")
            add_from_json("autosens")
            add_from_json("meal")
            add_from_json("iob")

            # USER ENTRY (smb/bolus/carbs) уже содержат timestamp
            for k in ("smb", "bolus", "carbs"):
                if k in fs and isinstance(fs[k], dict):
                    ts = fs[k].get("timestamp")
                    if ts is not None and ts > 0:
                        events.append(TimelineEvent(ts, k.upper(), fs[k], line))

        events.sort(key=lambda e: e.ts)
        return events

analysis/plots.py
from datetime import datetime
from typing import List, Dict, Any

from matplotlib.dates import DateFormatter, AutoDateLocator
from parser.timeline import TimelineEvent


# --------------------------
# ВСПОМОГАТЕЛЬНОЕ
# --------------------------

def _ts_to_dt(ts_ms: int):
    return datetime.utcfromtimestamp(ts_ms / 1000)


def _setup_time_axis(ax, title: str, ylabel: str):
    ax.set_title(title)
    ax.set_xlabel("Время")
    ax.set_ylabel(ylabel)
    ax.grid(True)
    ax.xaxis.set_major_formatter(DateFormatter("%d.%m %H:%M"))
    ax.xaxis.set_major_locator(AutoDateLocator())


def _nearest_bg(bg_events: List[TimelineEvent], ts: int):
    best = None
    best_dt = None
    for e in bg_events:
        dt = abs(e.ts - ts)
        if best is None or dt < best_dt:
            best = e
            best_dt = dt
    if not best:
        return None, None
    return _ts_to_dt(best.ts), best.data.get("glucose") or best.data.get("value")


# --------------------------
# UAM подсветка
# --------------------------

def _detect_uam_segments(bg_events: List[TimelineEvent], carb_events: List[TimelineEvent]):
    """
    Упрощённая UAM-логика:
    - dBG/dt > 0.2 ммоль/л за 5 минут
    - нет карбов последние 2 часа
    """
    if len(bg_events) < 2:
        return []

    carb_times = [c.ts for c in carb_events]
    segments = []

    def has_recent_carbs(ts, window_ms=2 * 60 * 60 * 1000):
        return any(abs(ts - t) <= window_ms for t in carb_times)

    bg_sorted = sorted(bg_events, key=lambda e: e.ts)

    for i in range(1, len(bg_sorted)):
        prev = bg_sorted[i - 1]
        cur = bg_sorted[i]

        dt_min = (cur.ts - prev.ts) / 60000.0
        if dt_min <= 0:
            continue

        prev_bg = prev.data.get("glucose") or prev.data.get("value")
        cur_bg = cur.data.get("glucose") or cur.data.get("value")

        dv = cur_bg - prev_bg
        rate = dv / dt_min

        if rate > 0.2 and not has_recent_carbs(cur.ts):
            segments.append((prev.ts, cur.ts))

    return segments


# --------------------------
# ОСНОВНАЯ ФУНКЦИЯ
# --------------------------

def build_overview_layers(fig, events: List[TimelineEvent]) -> Dict[str, Any]:
    """
    Строит все слои:
    - BG
    - PredBG
    - IOB
    - COB
    - SMB / Bolus / Carbs
    - UAM подсветка
    - вертикальные линии
    """

    fig.clear()
    ax1 = fig.add_subplot(111)
    ax2 = ax1.twinx()

    # Разделяем события по типам
    bg = [e for e in events if e.kind == "GLUCOSE"]
    iob = [e for e in events if e.kind == "IOB"]
    cob = [e for e in events if e.kind == "MEAL"]
    pred = [e for e in events if e.kind == "RESULT"]
    smb = [e for e in events if e.kind == "SMB"]
    bolus = [e for e in events if e.kind == "BOLUS"]
    carbs = [e for e in events if e.kind == "CARBS"]

    layers: Dict[str, Any] = {}

    # --------------------------
    # BG
    # --------------------------

    if not bg:
        _setup_time_axis(ax1, "Нет BG данных", "BG")
        fig.tight_layout()
        return layers

    bg_x = [_ts_to_dt(e.ts) for e in bg]
    bg_y = [e.data.get("glucose") or e.data.get("value") for e in bg]

    ln_bg, = ax1.plot(bg_x, bg_y, color="red", label="BG")
    layers["BG"] = ln_bg

    # --------------------------
    # PredBG (из resultJson.predBGs)
    # --------------------------

    if pred:
        pred_x = []
        pred_y = []

        for e in pred:
            ts = e.ts
            dt = _ts_to_dt(ts)

            predBGs = e.data.get("predBGs")
            if predBGs and "IOB" in predBGs:
                pred_x.append(dt)
                pred_y.append(predBGs["IOB"][0])
            else:
                pred_x.append(dt)
                pred_y.append(None)

        ln_pred, = ax1.plot(pred_x, pred_y, color="green", linestyle="--", label="PredBG")
        layers["PredBG"] = ln_pred
    else:
        layers["PredBG"] = ax1.plot([], [])[0]

    # --------------------------
    # IOB
    # --------------------------

    if iob:
        iob_x = [_ts_to_dt(e.ts) for e in iob]
        iob_y = [e.data.get("iob") for e in iob]

        ln_iob, = ax2.plot(iob_x, iob_y, color="blue", label="IOB")
        layers["IOB"] = ln_iob
    else:
        layers["IOB"] = ax2.plot([], [])[0]

    # --------------------------
    # COB
    # --------------------------

    if cob:
        cob_x = [_ts_to_dt(e.ts) for e in cob]
        cob_y = [e.data.get("mealCOB") or e.data.get("cob") for e in cob]

        ln_cob, = ax2.plot(cob_x, cob_y, color="orange", label="COB")
        layers["COB"] = ln_cob
    else:
        layers["COB"] = ax2.plot([], [])[0]

    # --------------------------
    # UAM подсветка
    # --------------------------

    uam_segments = _detect_uam_segments(bg, carbs)
    for start_ts, end_ts in uam_segments:
        ax1.axvspan(_ts_to_dt(start_ts), _ts_to_dt(end_ts), color="red", alpha=0.1)

    # --------------------------
    # SMB / Bolus / Carbs
    # --------------------------

    smb_objs = []
    bolus_objs = []
    carbs_objs = []

    # SMB
    smb_x, smb_y, smb_txt = [], [], []
    for e in smb:
        x, y = _nearest_bg(bg, e.ts)
        if x is None:
            continue
        smb_x.append(x)
        smb_y.append(y)
        smb_txt.append(f"{e.data.get('insulin', 0)}U")

    if smb_x:
        sc = ax1.scatter(smb_x, smb_y, color="cyan", label="SMB")
        smb_objs.append(sc)
        for x, y, t in zip(smb_x, smb_y, smb_txt):
            smb_objs.append(ax1.text(x, y, t, fontsize=8, color="cyan"))

    # Bolus
    bol_x, bol_y, bol_txt = [], [], []
    for e in bolus:
        x, y = _nearest_bg(bg, e.ts)
        if x is None:
            continue
        bol_x.append(x)
        bol_y.append(y)
        bol_txt.append(f"{e.data.get('insulin', 0)}U")

    if bol_x:
        sc = ax1.scatter(bol_x, bol_y, color="lime", label="Bolus")
        bolus_objs.append(sc)
        for x, y, t in zip(bol_x, bol_y, bol_txt):
            bolus_objs.append(ax1.text(x, y, t, fontsize=8, color="lime"))
        for x in bol_x:
            bolus_objs.append(ax1.axvline(x=x, color="lime", alpha=0.3))

    # Carbs
    carb_x, carb_y, carb_txt = [], [], []
    for e in carbs:
        x, y = _nearest_bg(bg, e.ts)
        if x is None:
            continue
        carb_x.append(x)
        carb_y.append(y)
        carb_txt.append(f"{e.data.get('carbs', 0)}g")

    if carb_x:
        sc = ax1.scatter(carb_x, carb_y, color="yellow", edgecolors="black", label="Carbs")
        carbs_objs.append(sc)
        for x, y, t in zip(carb_x, carb_y, carb_txt):
            carbs_objs.append(ax1.text(x, y, t, fontsize=8, color="black"))
        for x in carb_x:
            carbs_objs.append(ax1.axvline(x=x, color="yellow", alpha=0.3))

    layers["SMB"] = smb_objs
    layers["Bolus"] = bolus_objs
    layers["Carbs"] = carbs_objs

    # --------------------------
    # Финализация
    # --------------------------

    _setup_time_axis(ax1, "Overview", "BG")
    ax2.set_ylabel("IOB / COB")

    fig.tight_layout()
    return layers

parser/file_loader.py
import os
import gzip
import zipfile


class LogFileLoader:
    """
    Универсальный загрузчик:
    - читает ZIP с любым именем
    - читает все файлы внутри ZIP
    - читает любые .txt, .log, .gz
    - читает любые файлы, содержащие APS-данные
    """

    def __init__(self, folder: str):
        self.folder = folder

    def iter_log_files(self):
        """
        Возвращает ВСЕ файлы:
        - любые ZIP
        - любые .txt, .log, .gz
        - любые файлы внутри ZIP
        """
        for root, _, files in os.walk(self.folder):
            for name in files:
                path = os.path.join(root, name)

                # ZIP — читаем всегда
                if name.lower().endswith(".zip"):
                    yield ("zip", path)
                    continue

                # любые текстовые файлы
                if (
                    name.lower().endswith(".txt")
                    or name.lower().endswith(".log")
                    or name.lower().endswith(".gz")
                    or ".log" in name.lower()  # AndroidAPS.2026-01-14.0.log
                    or ".txt" in name.lower()  # странные имена типа "[.txt"
                ):
                    yield ("file", path)

    def iter_log_lines(self):
        """
        Возвращает строки из всех файлов.
        """
        for ftype, path in self.iter_log_files():

            # -----------------------------
            # ZIP-файл — читаем ВСЁ внутри
            # -----------------------------
            if ftype == "zip":
                try:
                    with zipfile.ZipFile(path, "r") as z:
                        for fname in z.namelist():
                            # читаем любые файлы внутри ZIP
                            with z.open(fname, "r") as f:
                                try:
                                    for line in f:
                                        yield line.decode("utf-8", errors="ignore").strip()
                                except Exception:
                                    pass
                except Exception as e:
                    print(f"[ZIP ERROR] {path}: {e}")
                continue

            # -----------------------------
            # Обычный файл
            # -----------------------------
            if path.endswith(".gz"):
                opener = gzip.open
                mode = "rt"
            else:
                opener = open
                mode = "r"

            try:
                with opener(path, mode, encoding="utf-8", errors="ignore") as f:
                    for line in f:
                        yield line.strip()
            except Exception as e:
                print(f"[FILE ERROR] {path}: {e}")
